```lean
import GlimpseOfLean.Library.Basic
import Mathlib.Data.Complex.Exponential
open Real
```

# 计算

## ring 策略

在学习数学时遇到的最早的一种证明类型之一是通过计算进行证明。这可能听起来不像是一个证明，但实际上是使用了表示数字运算性质的引理。当然，我们通常不想显式地调用这些引理，所以 mathlib 提供了一个名为 `ring` 的策略，它可以证明通过应用所有可交换环的性质而得到的等式。

```lean
example (a b c : ℝ) : (a * b) * c = b * (a * c) := by {
  ring
}
```

现在轮到你了，在下面的代码中，用一个证明替换掉 `sorry` 这个词。在这种情况下，证明就是 `ring`。在你证明完毕后，你将看到一个 "No goals" 的小提示，这表示你的证明已经完成了。

```lean
example (a b : ℝ) : (a+b)^2 = a^2 + 2*a*b + b^2 := by {
  sorry
}
```

在上面的第一个示例中，仔细观察 Lean 显示括号的位置。`ring` 策略肯定知道乘法的结合性，但有时了解二元运算真正是二元的，例如表达式 `a*b*c` 在 Lean 中被解读为 `(a*b)*c`，而它与 `a*(b*c)` 相等的事实是 `ring` 策略在需要时使用的一个引理。

## rewrite 策略

现在让我们看看如何使用涉及到的数之间的假设进行计算。这利用了等式的基本性质：如果两个数学对象 A 和 B 相等，那么在涉及到 A 的任何陈述中，可以用 B 替换 A。这个操作被称为重写，而 Lean 中的策略是 `rw`。仔细地逐步进行以下证明，并尝试理解正在发生的事情。

```lean
example (a b c d e : ℝ) (h : a = b + c) (h' : b = d - e) : a + e = d + c := by {
  rw [h]
  rw [h']
  ring
}
```

注意，`rw` 策略改变了当前的目标。在上述证明的第一行之后，新的目标是 `b + c + e = d + c`。因此，你可以理解这个第一步证明为说："我想要证明 `a + e = d + c`，但是，由于假设 `h` 告诉我 `a = b + c`，
# 计算

## ring 策略

在学习数学时，我们遇到的最早的一种证明类型之一是通过计算进行证明。这可能听起来不像是一个证明，但实际上是使用了表示数字运算性质的引理。当然，我们通常不想显式地调用这些引理，所以 mathlib 提供了一个名为 `ring` 的策略，它可以证明通过应用所有可交换环的性质而得到的等式。

```lean
example (a b c : ℝ) : (a * b) * c = b * (a * c) := by {
  ring
}
```

现在轮到你了，在下面的代码中，用一个证明替换掉 `sorry` 这个词。在这种情况下，证明就是 `ring`。在你证明完毕后，你将看到一个 "No goals" 的小提示，这表示你的证明已经完成了。

```lean
example (a b : ℝ) : (a+b)^2 = a^2 + 2*a*b + b^2 := by {
  sorry
}
```

在上面的第一个示例中，仔细观察 Lean 显示括号的位置。`ring` 策略肯定知道乘法的结合性，但有时了解二元运算真正是二元的，例如表达式 `a*b*c` 在 Lean 中被解读为 `(a*b)*c`，而它与 `a*(b*c)` 相等的事实是 `ring` 策略在需要时使用的一个引理。

## rewrite 策略

现在让我们看看如何使用涉及到的数之间的假设进行计算。这利用了等式的基本性质：如果两个数学对象 A 和 B 相等，那么在涉及到 A 的任何陈述中，可以用 B 替换 A。这个操作被称为重写，而 Lean 中的策略是 `rw`。仔细地逐步进行以下证明，并尝试理解正在发生的事情。

```lean
example (a b c d e : ℝ) (h : a = b + c) (h' : b = d - e) : a + e = d + c := by {
  rw [h]
  rw [h']
  ring
}
```

注意，`rw` 策略改变了当前的目标。在上述证明的第一行之后，新的目标是 `b + c + e = d + c`。因此，你可以理解这个第一步证明为说："我想要证明 `a + e = d + c`，但是，由于假设 `h` 告诉我 `a = b + c`，所以我可以用 `b + c + e` 替换 `a`。"同样，第二行证明可以理解为使用假设 `h'`，将 `b` 替换为 `d - e`。

注意策略状态中微妙的背景颜色变化，以绿色显示的是新添加进来的内容，以红色显示的是即将改变的内容。

现在你可以自己尝试一下。请注意，`ring` 策略仍然可以进行计算，但它不使用假设 `h` 和 `h'`。

```lean
example (a b c d : ℝ) (h : b = d + d) (h' : a = b + c) : a + b = c + 4 * d := by {
  sorry
}
```

## 使用引理重写

在上面的示例中，我们使用了局部假设来重写目标。但我们也可以使用引理。例如，让我们证明一个关于指数的引理。由于 `ring` 只知道如何从环的公理中证明事实，它不知道如何处理指数运算。对于下面的引理，我们将分别两次重写，使用的是引理 `exp_add x y`，它证明了 `exp(x+y) = exp(x) * exp(y)`。

```lean
example (a b c : ℝ) : exp (a + b + c) = exp a * exp b * exp c := by {
  rw [exp_add (a + b) c]
  rw [exp_add a b]
}
```

还要注意，在第二次 `rw` 之后，目标变成了 `exp a * exp b * exp c = exp a * exp b * exp c`，而 Lean 立即声明证明完成。

如果我们不给引理提供参数，Lean 将重写第一个匹配的子表达式。在我们的例子中，这足够好用。但有时可能需要更多的控制。

```lean
example (a b c : ℝ) : exp (a + b + c) = exp a * exp b * exp c := by {
  rw [exp_add, exp_add]
}
```

让我们做一个练习，你还需要使用 `exp_sub x y : exp(x-y) = exp(x) / exp(y)` 和 `exp_zero : exp 0 = 1`。

请记住，`a + b - c` 表示 `(a + b) - c`。

你可以使用 `ring`，也可以使用 `mul_one x : x * 1 = x` 来简化右侧分母的表达式。

```lean
example (a b c : ℝ) : exp (a + b - c) = (exp a * exp b) / (exp c * exp 0) := by {
  sorry
}
```
## 从右向左重写

由于等号是一个对称关系，我们也可以使用 `←` 将等式的右边替换为左边，如下面的例子所示。

```lean
example (a b c : ℝ) (h : a = b + c) (h' : a + e = d + c) : b + c + e = d + c := by {
  rw [← h, h']
}
```

当你在 Lean 文件中看到一个你的键盘上找不到的符号，比如 ←，你可以将鼠标光标放在其上方，从提示中了解如何输入它。对于 ←，可以通过输入“\l”（反斜杠-l-空格）来输入它。

请注意，从右向左的重写是关于你想要“使用”的等式两侧的事情，而不是关于你想要“证明”的两侧。`rw [← h]` 将用左侧来替换右侧，所以它将在当前的目标中查找 `b + c` 并将其替换为 `a`。

```lean
example (a b c d : ℝ) (h : a = b + b) (h' : b = c) (h'' : a = d) : b + c = d := by {
  sorry
}
```

## 在局部假设中进行重写

我们还可以在局部上下文的假设中进行重写，例如使用 `rw [exp_add x y] at h` 将假设 `h` 中的 `exp(x + y)` 替换为 `exp(x) * exp(y)`。

`tactic.exact` 策略允许你为当前的目标给出一个显式的证明项来证明它。

```lean
example (a b c d : ℝ) (h : c = d*a - b) (h' : b = a*d) : c = 0 := by {
  rw [h'] at h
  ring at h
  -- 现在我们的假设 `h` 正好就是我们要证明的内容
  exact h
}
```

## 使用 `calc` 进行计算布局

上面的例子的表达方式与我们在纸上写的方式相去甚远。现在让我们看一下如何获得一个更自然的布局（同时返回使用 `ring` 而不是显式引用引理）。
在下面的每个 `:=` 之后，目标是证明与前一行相等（或者第一行的左边）的内容。
通过将光标放在每个 `by` 后面并查看策略状态，仔细检查是否理解了这个过程。

```lean
example (a b c d : ℝ) (h : c = b*a - d) (h' : d = a*b) : c = 0 := by {
  calc
    c = b*a - d   := by rw [h]
    _ = b*a - a*b := by rw [h']
    _ = 0         := by ring
}
```
让我们通过使用 `calc` 进行一些练习。

```lean
example (a b c : ℝ) (h : a = b + c) : exp (2 * a) = (exp b) ^ 2 * (exp c) ^ 2 := by {
  calc
    exp (2 * a) = exp (2 * (b + c))                 := by sorry
              _ = exp ((b + b) + (c + c))           := by sorry
              _ = exp (b + b) * exp (c + c)         := by sorry
              _ = (exp b * exp b) * (exp c * exp c) := by sorry
              _ = (exp b) ^ 2 * (exp c)^2           := by sorry
}
```

从实用角度来看，在编写这样的证明时，有时可以：
- 在 VSCode 中通过点击 Lean Infoview 面板右上角的 "Pause" 图标按钮来暂停策略状态视图的更新。
- 编写完整的计算过程，每行末尾加上 `:= ?_`。
- 通过点击 "Play" 图标按钮来恢复策略状态的更新，然后填写证明。

下划线应该放置在第一行下面 `calc` 下面第一个行右侧的 `:=` 的下方。对齐等号和 `:=` 不是必需的，但看起来更整齐。

```lean
example (a b c d : ℝ) (h : c = d*a + b) (h' : b = a*d) : c = 2*a*d := by {
  sorry
}
```

恭喜！这是你的第一个练习文件的结尾！你已经看到了 Lean 证明的输入方式，并学习了以下策略：
- `ring`
- `rw`
- `exact`
- `calc`
